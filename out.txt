=== app/layout.tsx ===
import { Toaster } from 'sonner';
import type { Metadata } from 'next';
import { Geist, Geist_Mono } from 'next/font/google';
import { ThemeProvider } from '@/components/theme-provider';

import './globals.css';
import { SessionProvider } from 'next-auth/react';

export const metadata: Metadata = {
  metadataBase: new URL('https://chat.vercel.ai'),
  title: 'Next.js Chatbot Template',
  description: 'Next.js chatbot template using the AI SDK.',
};

export const viewport = {
  maximumScale: 1, // Disable auto-zoom on mobile Safari
};

const geist = Geist({
  subsets: ['latin'],
  display: 'swap',
  variable: '--font-geist',
});

const geistMono = Geist_Mono({
  subsets: ['latin'],
  display: 'swap',
  variable: '--font-geist-mono',
});

const LIGHT_THEME_COLOR = 'hsl(0 0% 100%)';
const DARK_THEME_COLOR = 'hsl(240deg 10% 3.92%)';
const THEME_COLOR_SCRIPT = `\
(function() {
  var html = document.documentElement;
  var meta = document.querySelector('meta[name="theme-color"]');
  if (!meta) {
    meta = document.createElement('meta');
    meta.setAttribute('name', 'theme-color');
    document.head.appendChild(meta);
  }
  function updateThemeColor() {
    var isDark = html.classList.contains('dark');
    meta.setAttribute('content', isDark ? '${DARK_THEME_COLOR}' : '${LIGHT_THEME_COLOR}');
  }
  var observer = new MutationObserver(updateThemeColor);
  observer.observe(html, { attributes: true, attributeFilter: ['class'] });
  updateThemeColor();
})();`;

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html
      lang="en"
      // `next-themes` injects an extra classname to the body element to avoid
      // visual flicker before hydration. Hence the `suppressHydrationWarning`
      // prop is necessary to avoid the React hydration mismatch warning.
      // https://github.com/pacocoursey/next-themes?tab=readme-ov-file#with-app
      suppressHydrationWarning
      className={`${geist.variable} ${geistMono.variable}`}
    >
      <head>
        <script
          dangerouslySetInnerHTML={{
            __html: THEME_COLOR_SCRIPT,
          }}
        />
      </head>
      <body className="antialiased">
        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
        >
          <Toaster position="top-center" />
          <SessionProvider>{children}</SessionProvider>
        </ThemeProvider>
      </body>
    </html>
  );
}

=== app/api/auth/[...nextauth]/route.ts ===
// app/api/auth/[...nextauth]/route.ts (chat app)
export { GET, POST } from '@/lib/auth/auth';
=== app/(chat)/chat/[id]/page.tsx ===
// app/(chat)/chat/[id]/page.tsx
import { cookies } from 'next/headers';
import { notFound, redirect } from 'next/navigation';

import { authOrDev } from '@/lib/auth/auth';
import { Chat } from '@/components/chat';
import { getChatById, getMessagesByChatId } from '@/lib/db/queries';
import { DataStreamHandler } from '@/components/data-stream-handler';
import { DEFAULT_CHAT_MODEL } from '@/lib/ai/models';
import { convertToUIMessages } from '@/lib/utils';

export default async function Page(props: { params: Promise<{ id: string }> }) {
    const params = await props.params;
    const { id } = params;
    const chat = await getChatById({ id });

    if (!chat) {
        notFound();
    }

    const session = await authOrDev();

    if (!session) {
        const host =
            process.env.NODE_ENV === 'production'
                ? 'https://chat.medbrevia.com'
                : 'http://localhost:3000';
        const callback = `${host}/chat/${id}`;
        redirect(
            `https://medbrevia.com/account/login?callbackUrl=${encodeURIComponent(
                callback,
            )}`,
        );
    }

    if (chat.visibility === 'private') {
        if (!session.user) {
            return notFound();
        }

        if (session.user.id !== chat.userId) {
            return notFound();
        }
    }

    const messagesFromDb = await getMessagesByChatId({ id });
    const uiMessages = convertToUIMessages(messagesFromDb);

    const cookieStore = await cookies();
    const chatModelFromCookie = cookieStore.get('chat-model');

    if (!chatModelFromCookie) {
        return (
            <>
                <Chat
                    id={chat.id}
                    initialMessages={uiMessages}
                    initialChatModel={DEFAULT_CHAT_MODEL}
                    initialVisibilityType={chat.visibility}
                    isReadonly={session?.user?.id !== chat.userId}
                    session={session}
                    autoResume={true}
                />
                <DataStreamHandler />
            </>
        );
    }

    return (
        <>
            <Chat
                id={chat.id}
                initialMessages={uiMessages}
                initialChatModel={chatModelFromCookie.value}
                initialVisibilityType={chat.visibility}
                isReadonly={session?.user?.id !== chat.userId}
                session={session}
                autoResume={true}
            />
            <DataStreamHandler />
        </>
    );
}

=== app/(chat)/actions.ts ===
'use server';

import { generateText, type UIMessage } from 'ai';
import { cookies } from 'next/headers';
import {
  deleteMessagesByChatIdAfterTimestamp,
  getMessageById,
  updateChatVisiblityById,
} from '@/lib/db/queries';
import type { VisibilityType } from '@/components/visibility-selector';
import { myProvider } from '@/lib/ai/providers';

export async function saveChatModelAsCookie(model: string) {
  const cookieStore = await cookies();
  cookieStore.set('chat-model', model);
}

export async function generateTitleFromUserMessage({
  message,
}: {
  message: UIMessage;
}) {
  const { text: title } = await generateText({
    model: myProvider.languageModel('title-model'),
    system: `\n
    - you will generate a short title based on the first message a user begins a conversation with
    - ensure it is not more than 80 characters long
    - the title should be a summary of the user's message
    - do not use quotes or colons`,
    prompt: JSON.stringify(message),
  });

  return title;
}

export async function deleteTrailingMessages({ id }: { id: string }) {
  const [message] = await getMessageById({ id });

  await deleteMessagesByChatIdAfterTimestamp({
    chatId: message.chatId,
    timestamp: message.createdAt,
  });
}

export async function updateChatVisibility({
  chatId,
  visibility,
}: {
  chatId: string;
  visibility: VisibilityType;
}) {
  await updateChatVisiblityById({ chatId, visibility });
}

=== app/(chat)/layout.tsx ===
// app/(chat)/layout.tsx
import {cookies} from 'next/headers';

import {AppSidebar} from '@/components/app-sidebar';
import {SidebarInset, SidebarProvider} from '@/components/ui/sidebar';
import {authOrDev} from '@/lib/auth/auth';
import Script from 'next/script';
import {DataStreamProvider} from '@/components/data-stream-provider';

export const experimental_ppr = true;

export default async function Layout({
                                         children,
                                     }: {
    children: React.ReactNode;
}) {
    const [session, cookieStore] = await Promise.all([authOrDev(), cookies()]);
    const isCollapsed = cookieStore.get('sidebar:state')?.value !== 'true';

    return (
        <>
            <Script
                src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"
                strategy="beforeInteractive"
            />
            <DataStreamProvider>
                <SidebarProvider defaultOpen={!isCollapsed}>
                    <AppSidebar user={session?.user}/>
                    <SidebarInset>{children}</SidebarInset>
                </SidebarProvider>
            </DataStreamProvider>
        </>
    );
}
=== app/(chat)/api/vote/route.ts ===
import {authOrDev} from '@/lib/auth/auth';
import {getChatById, getVotesByChatId, voteMessage} from '@/lib/db/queries';
import {ChatSDKError} from '@/lib/errors';

export async function GET(request: Request) {
    const {searchParams} = new URL(request.url);
    const chatId = searchParams.get('chatId');

    if (!chatId) {
        return new ChatSDKError(
            'bad_request:api',
            'Parameter chatId is required.',
        ).toResponse();
    }

    const session = await authOrDev();

    if (!session?.user) {
        return new ChatSDKError('unauthorized:vote').toResponse();
    }

    const chat = await getChatById({id: chatId});

    if (!chat) {
        return new ChatSDKError('not_found:chat').toResponse();
    }

    if (chat.userId !== session.user.id) {
        return new ChatSDKError('forbidden:vote').toResponse();
    }

    const votes = await getVotesByChatId({id: chatId});

    return Response.json(votes, {status: 200});
}

export async function PATCH(request: Request) {
    const {
        chatId,
        messageId,
        type,
    }: { chatId: string; messageId: string; type: 'up' | 'down' } =
        await request.json();

    if (!chatId || !messageId || !type) {
        return new ChatSDKError(
            'bad_request:api',
            'Parameters chatId, messageId, and type are required.',
        ).toResponse();
    }

    const session = await authOrDev();

    if (!session?.user) {
        return new ChatSDKError('unauthorized:vote').toResponse();
    }

    const chat = await getChatById({id: chatId});

    if (!chat) {
        return new ChatSDKError('not_found:vote').toResponse();
    }

    if (chat.userId !== session.user.id) {
        return new ChatSDKError('forbidden:vote').toResponse();
    }

    await voteMessage({
        chatId,
        messageId,
        type: type,
    });

    return new Response('Message voted', {status: 200});
}
=== app/(chat)/api/chat/schema.ts ===
import { z } from 'zod';

const textPartSchema = z.object({
  type: z.enum(['text']),
  text: z.string().min(1).max(2000),
});

const filePartSchema = z.object({
  type: z.enum(['file']),
  mediaType: z.enum(['image/jpeg', 'image/png']),
  name: z.string().min(1).max(100),
  url: z.string().url(),
});

const partSchema = z.union([textPartSchema, filePartSchema]);

export const postRequestBodySchema = z.object({
  id: z.string().uuid(),
  message: z.object({
    id: z.string().uuid(),
    role: z.enum(['user']),
    parts: z.array(partSchema),
  }),
  selectedChatModel: z.enum(['chat-model', 'chat-model-reasoning']),
  selectedVisibilityType: z.enum(['public', 'private']),
});

export type PostRequestBody = z.infer<typeof postRequestBodySchema>;

=== app/(chat)/api/chat/route.ts ===
import {
    convertToModelMessages,
    createUIMessageStream,
    JsonToSseTransformStream,
    smoothStream,
    stepCountIs,
    streamText,
} from 'ai';
import {authOrDev} from '@/lib/auth/auth';
import {type RequestHints, systemPrompt} from '@/lib/ai/prompts';
import {
    createStreamId,
    deleteChatById,
    getChatById,
    getMessageCountByUserId,
    getMessagesByChatId,
    saveChat,
    saveMessages,
} from '@/lib/db/queries';
import {convertToUIMessages, generateUUID} from '@/lib/utils';
import {generateTitleFromUserMessage} from '../../actions';
import {createDocument} from '@/lib/ai/tools/create-document';
import {updateDocument} from '@/lib/ai/tools/update-document';
import {requestSuggestions} from '@/lib/ai/tools/request-suggestions';
import {isProductionEnvironment} from '@/lib/constants';
import {myProvider} from '@/lib/ai/providers';
import {postRequestBodySchema, type PostRequestBody} from './schema';
import {geolocation} from '@vercel/functions';
import {
    createResumableStreamContext,
    type ResumableStreamContext,
} from 'resumable-stream';
import {after} from 'next/server';
import {ChatSDKError} from '@/lib/errors';
import type {ChatMessage} from '@/lib/types';
import type {ChatModel} from '@/lib/ai/models';
import type {VisibilityType} from '@/components/visibility-selector';

export const maxDuration = 60;

let globalStreamContext: ResumableStreamContext | null = null;

export function getStreamContext() {
    if (!globalStreamContext) {
        try {
            globalStreamContext = createResumableStreamContext({
                waitUntil: after,
            });
        } catch (error: any) {
            if (error.message.includes('REDIS_URL')) {
                console.log(
                    ' > Resumable streams are disabled due to missing REDIS_URL',
                );
            } else {
                console.error(error);
            }
        }
    }

    return globalStreamContext;
}

export async function POST(request: Request) {
    let requestBody: PostRequestBody;

    try {
        const json = await request.json();
        requestBody = postRequestBodySchema.parse(json);
    } catch (err) {
        console.log(err)
        return new ChatSDKError('bad_request:api').toResponse();
    }

    try {
        const {
            id,
            message,
            selectedChatModel,
            selectedVisibilityType,
        }: {
            id: string;
            message: ChatMessage;
            selectedChatModel: ChatModel['id'];
            selectedVisibilityType: VisibilityType;
        } = requestBody;

        const session = await authOrDev();

        if (!session?.user) {
            return new ChatSDKError('unauthorized:chat').toResponse();
        }

        // TODO: keep rate-limit logic gated behind an env flag in the future.

        const chat = await getChatById({id});

        if (!chat) {
            const title = await generateTitleFromUserMessage({
                message,
            });

            await saveChat({
                id,
                userId: session.user.id,
                title,
                visibility: selectedVisibilityType,
            });
        } else {
            if (chat.userId !== session.user.id) {
                return new ChatSDKError('forbidden:chat').toResponse();
            }
        }

        const messagesFromDb = await getMessagesByChatId({id});
        const uiMessages = [...convertToUIMessages(messagesFromDb), message];

        const {longitude, latitude, city, country} = geolocation(request);

        const requestHints: RequestHints = {
            longitude,
            latitude,
            city,
            country,
        };

        await saveMessages({
            messages: [
                {
                    chatId: id,
                    id: message.id,
                    role: 'user',
                    parts: message.parts,
                    attachments: [],
                    createdAt: new Date(),
                },
            ],
        });

        const streamId = generateUUID();
        await createStreamId({streamId, chatId: id});

        const stream = createUIMessageStream({
            execute: ({writer: dataStream}) => {
                const result = streamText({
                    model: myProvider.languageModel(selectedChatModel),
                    system: systemPrompt({selectedChatModel, requestHints}),
                    messages: convertToModelMessages(uiMessages),
                    stopWhen: stepCountIs(5),
                    experimental_activeTools:
                        selectedChatModel === 'chat-model-reasoning'
                            ? []
                            : ['createDocument', 'updateDocument', 'requestSuggestions'],
                    experimental_transform: smoothStream({chunking: 'word'}),
                    tools: {
                        createDocument: createDocument({session, dataStream}),
                        updateDocument: updateDocument({session, dataStream}),
                        requestSuggestions: requestSuggestions({
                            session,
                            dataStream,
                        }),
                    },
                    experimental_telemetry: {
                        isEnabled: isProductionEnvironment,
                        functionId: 'stream-text',
                    },
                });

                result.consumeStream();

                dataStream.merge(
                    result.toUIMessageStream({
                        sendReasoning: true,
                    }),
                );
            },
            generateId: generateUUID,
            onFinish: async ({messages}) => {
                await saveMessages({
                    messages: messages.map((message) => ({
                        id: message.id,
                        role: message.role,
                        parts: message.parts,
                        createdAt: new Date(),
                        attachments: [],
                        chatId: id,
                    })),
                });
            },
            onError: () => {
                return 'Oops, an error occurred!';
            },
        });

        const streamContext = getStreamContext();

        if (streamContext) {
            return new Response(
                await streamContext.resumableStream(streamId, () =>
                    stream.pipeThrough(new JsonToSseTransformStream()),
                ),
            );
        } else {
            return new Response(stream.pipeThrough(new JsonToSseTransformStream()));
        }
    } catch (error) {
        if (error instanceof ChatSDKError) {
            console.log(error)
            return error.toResponse();
        }
    }
}

export async function DELETE(request: Request) {
    const {searchParams} = new URL(request.url);
    const id = searchParams.get('id');

    if (!id) {
        return new ChatSDKError('bad_request:api').toResponse();
    }

    const session = await authOrDev();

    if (!session?.user) {
        return new ChatSDKError('unauthorized:chat').toResponse();
    }

    const chat = await getChatById({id});

    if (chat.userId !== session.user.id) {
        return new ChatSDKError('forbidden:chat').toResponse();
    }

    const deletedChat = await deleteChatById({id});

    return Response.json(deletedChat, {status: 200});
}

=== app/(chat)/api/chat/[id]/stream/route.ts ===
import {authOrDev} from '@/lib/auth/auth';
import {
    getChatById,
    getMessagesByChatId,
    getStreamIdsByChatId,
} from '@/lib/db/queries';
import type {Chat} from '@/lib/db/schema';
import {ChatSDKError} from '@/lib/errors';
import type {ChatMessage} from '@/lib/types';
import {createUIMessageStream, JsonToSseTransformStream} from 'ai';
import {getStreamContext} from '../../route';
import {differenceInSeconds} from 'date-fns';

export async function GET(
    _: Request,
    {params}: { params: Promise<{ id: string }> },
) {
    const {id: chatId} = await params;

    const streamContext = getStreamContext();
    const resumeRequestedAt = new Date();

    if (!streamContext) {
        return new Response(null, {status: 204});
    }

    if (!chatId) {
        return new ChatSDKError('bad_request:api').toResponse();
    }

    const session = await authOrDev();

    if (!session?.user) {
        return new ChatSDKError('unauthorized:chat').toResponse();
    }

    let chat: Chat;

    try {
        chat = await getChatById({id: chatId});
    } catch {
        return new ChatSDKError('not_found:chat').toResponse();
    }

    if (!chat) {
        return new ChatSDKError('not_found:chat').toResponse();
    }

    if (chat.visibility === 'private' && chat.userId !== session.user.id) {
        return new ChatSDKError('forbidden:chat').toResponse();
    }

    const streamIds = await getStreamIdsByChatId({chatId});

    if (!streamIds.length) {
        return new ChatSDKError('not_found:stream').toResponse();
    }

    const recentStreamId = streamIds.at(-1);

    if (!recentStreamId) {
        return new ChatSDKError('not_found:stream').toResponse();
    }

    const emptyDataStream = createUIMessageStream<ChatMessage>({
        execute: () => {
        },
    });

    const stream = await streamContext.resumableStream(recentStreamId, () =>
        emptyDataStream.pipeThrough(new JsonToSseTransformStream()),
    );

    /*
     * If the resumable stream concluded just now, try to restore the last assistant message.
     */
    if (!stream) {
        const messages = await getMessagesByChatId({id: chatId});
        const mostRecentMessage = messages.at(-1);

        if (!mostRecentMessage) {
            return new Response(emptyDataStream, {status: 200});
        }

        if (mostRecentMessage.role !== 'assistant') {
            return new Response(emptyDataStream, {status: 200});
        }

        const messageCreatedAt = new Date(mostRecentMessage.createdAt);

        if (differenceInSeconds(resumeRequestedAt, messageCreatedAt) > 15) {
            return new Response(emptyDataStream, {status: 200});
        }

        const restoredStream = createUIMessageStream<ChatMessage>({
            execute: ({writer}) => {
                writer.write({
                    type: 'data-appendMessage',
                    data: JSON.stringify(mostRecentMessage),
                    transient: true,
                });
            },
        });

        return new Response(
            restoredStream.pipeThrough(new JsonToSseTransformStream()),
            {status: 200},
        );
    }

    return new Response(stream, {status: 200});
}

=== app/(chat)/api/document/route.ts ===
import {authOrDev} from '@/lib/auth/auth';
import type {ArtifactKind} from '@/components/artifact';
import {
    deleteDocumentsByIdAfterTimestamp,
    getDocumentsById,
    saveDocument,
} from '@/lib/db/queries';
import {ChatSDKError} from '@/lib/errors';

export async function GET(request: Request) {
    const {searchParams} = new URL(request.url);
    const id = searchParams.get('id');

    if (!id) {
        return new ChatSDKError(
            'bad_request:api',
            'Parameter id is missing',
        ).toResponse();
    }

    const session = await authOrDev();

    if (!session?.user) {
        return new ChatSDKError('unauthorized:document').toResponse();
    }

    const documents = await getDocumentsById({id});

    const [document] = documents;

    if (!document) {
        return new ChatSDKError('not_found:document').toResponse();
    }

    if (document.userId !== session.user.id) {
        return new ChatSDKError('forbidden:document').toResponse();
    }

    return Response.json(documents, {status: 200});
}

export async function POST(request: Request) {
    const {searchParams} = new URL(request.url);
    const id = searchParams.get('id');

    if (!id) {
        return new ChatSDKError(
            'bad_request:api',
            'Parameter id is required.',
        ).toResponse();
    }

    const session = await authOrDev();

    if (!session?.user) {
        return new ChatSDKError('not_found:document').toResponse();
    }

    const {
        content,
        title,
        kind,
    }: { content: string; title: string; kind: ArtifactKind } =
        await request.json();

    const documents = await getDocumentsById({id});

    if (documents.length > 0) {
        const [document] = documents;

        if (document.userId !== session.user.id) {
            return new ChatSDKError('forbidden:document').toResponse();
        }
    }

    const document = await saveDocument({
        id,
        content,
        title,
        kind,
        userId: session.user.id,
    });

    return Response.json(document, {status: 200});
}

export async function DELETE(request: Request) {
    const {searchParams} = new URL(request.url);
    const id = searchParams.get('id');
    const timestamp = searchParams.get('timestamp');

    if (!id) {
        return new ChatSDKError(
            'bad_request:api',
            'Parameter id is required.',
        ).toResponse();
    }

    if (!timestamp) {
        return new ChatSDKError(
            'bad_request:api',
            'Parameter timestamp is required.',
        ).toResponse();
    }

    const session = await authOrDev();

    if (!session?.user) {
        return new ChatSDKError('unauthorized:document').toResponse();
    }

    const documents = await getDocumentsById({id});

    const [document] = documents;

    if (document.userId !== session.user.id) {
        return new ChatSDKError('forbidden:document').toResponse();
    }

    const documentsDeleted = await deleteDocumentsByIdAfterTimestamp({
        id,
        timestamp: new Date(timestamp),
    });

    return Response.json(documentsDeleted, {status: 200});
}
=== app/(chat)/api/history/route.ts ===
import {authOrDev} from '@/lib/auth/auth';
import type {NextRequest} from 'next/server';
import {getChatsByUserId} from '@/lib/db/queries';
import {ChatSDKError} from '@/lib/errors';

export async function GET(request: NextRequest) {
    const {searchParams} = request.nextUrl;

    const limit = Number.parseInt(searchParams.get('limit') || '10');
    const startingAfter = searchParams.get('starting_after');
    const endingBefore = searchParams.get('ending_before');

    if (startingAfter && endingBefore) {
        return new ChatSDKError(
            'bad_request:api',
            'Only one of starting_after or ending_before can be provided.',
        ).toResponse();
    }

    const session = await authOrDev();

    if (!session?.user) {
        return new ChatSDKError('unauthorized:chat').toResponse();
    }

    const chats = await getChatsByUserId({
        id: session.user.id,
        limit,
        startingAfter,
        endingBefore,
    });

    return Response.json(chats);
}

=== app/(chat)/api/files/upload/route.ts ===
import {put} from '@vercel/blob';
import {NextResponse} from 'next/server';
import {z} from 'zod';

import {authOrDev} from '@/lib/auth/auth';

// Use Blob instead of File since File is not available in Node.js environment
const FileSchema = z.object({
    file: z
        .instanceof(Blob)
        .refine((file) => file.size <= 5 * 1024 * 1024, {
            message: 'File size should be less than 5MB',
        })
        .refine((file) => ['image/jpeg', 'image/png'].includes(file.type), {
            message: 'File type should be JPEG or PNG',
        }),
});

export async function POST(request: Request) {
    const session = await authOrDev();

    if (!session) {
        return NextResponse.json({error: 'Unauthorized'}, {status: 401});
    }

    if (request.body === null) {
        return new Response('Request body is empty', {status: 400});
    }

    try {
        const formData = await request.formData();
        const file = formData.get('file') as Blob;

        if (!file) {
            return NextResponse.json({error: 'No file uploaded'}, {status: 400});
        }

        const validatedFile = FileSchema.safeParse({file});

        if (!validatedFile.success) {
            const errorMessage = validatedFile.error.errors
                .map((error) => error.message)
                .join(', ');

            return NextResponse.json({error: errorMessage}, {status: 400});
        }

        // Get filename from formData since Blob doesn't have name property
        const filename = (formData.get('file') as File).name;
        const fileBuffer = await file.arrayBuffer();

        try {
            const data = await put(`${filename}`, fileBuffer, {
                access: 'public',
            });

            return NextResponse.json(data);
        } catch (error) {
            return NextResponse.json({error: 'Upload failed'}, {status: 500});
        }
    } catch (error) {
        return NextResponse.json(
            {error: 'Failed to process request'},
            {status: 500},
        );
    }
}

=== app/(chat)/api/suggestions/route.ts ===
import {authOrDev} from '@/lib/auth/auth';
import {getSuggestionsByDocumentId} from '@/lib/db/queries';
import {ChatSDKError} from '@/lib/errors';

export async function GET(request: Request) {
    const {searchParams} = new URL(request.url);
    const documentId = searchParams.get('documentId');

    if (!documentId) {
        return new ChatSDKError(
            'bad_request:api',
            'Parameter documentId is required.',
        ).toResponse();
    }

    const session = await authOrDev();

    if (!session?.user) {
        return new ChatSDKError('unauthorized:suggestions').toResponse();
    }

    const suggestions = await getSuggestionsByDocumentId({
        documentId,
    });

    const [suggestion] = suggestions;

    if (!suggestion) {
        return Response.json([], {status: 200});
    }

    if (suggestion.userId !== session.user.id) {
        return new ChatSDKError('forbidden:api').toResponse();
    }

    return Response.json(suggestions, {status: 200});
}

=== app/(chat)/page.tsx ===
// app/(chat)/page.tsx
import {cookies} from 'next/headers';

import {Chat} from '@/components/chat';
import {DEFAULT_CHAT_MODEL} from '@/lib/ai/models';
import {generateUUID} from '@/lib/utils';
import {DataStreamHandler} from '@/components/data-stream-handler';
import {authOrDev} from '@/lib/auth/auth';
import {redirect} from 'next/navigation';

export default async function Page() {
    const session = await authOrDev();

    if (!session) {
        // Production-only redirect (authOrDev returns null only in prod)
        const host =
            process.env.NODE_ENV === 'production'
                ? 'https://chat.medbrevia.com'
                : 'http://localhost:3000';
        const callback = `${host}/`;
        redirect(
            `https://medbrevia.com/account/login?callbackUrl=${encodeURIComponent(
                callback,
            )}`,
        );
    }

    const id = generateUUID();

    const cookieStore = await cookies();
    const modelIdFromCookie = cookieStore.get('chat-model');

    if (!modelIdFromCookie) {
        return (
            <>
                <Chat
                    key={id}
                    id={id}
                    initialMessages={[]}
                    initialChatModel={DEFAULT_CHAT_MODEL}
                    initialVisibilityType="private"
                    isReadonly={false}
                    session={session}
                    autoResume={false}
                />
                <DataStreamHandler/>
            </>
        );
    }

    return (
        <>
            <Chat
                key={id}
                id={id}
                initialMessages={[]}
                initialChatModel={modelIdFromCookie.value}
                initialVisibilityType="private"
                isReadonly={false}
                session={session}
                autoResume={false}
            />
            <DataStreamHandler/>
        </>
    );
}
=== app/globals.css ===
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
    --foreground-rgb: 0, 0, 0;
    --background-start-rgb: 214, 219, 220;
    --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
    :root {
        --foreground-rgb: 255, 255, 255;
        --background-start-rgb: 0, 0, 0;
        --background-end-rgb: 0, 0, 0;
    }
}

@layer utilities {
    .text-balance {
        text-wrap: balance;
    }
}

@layer base {
    :root {
        --background: 0 0% 100%;
        --foreground: 240 10% 3.9%;
        --card: 0 0% 100%;
        --card-foreground: 240 10% 3.9%;
        --popover: 0 0% 100%;
        --popover-foreground: 240 10% 3.9%;
        --primary: 240 5.9% 10%;
        --primary-foreground: 0 0% 98%;
        --secondary: 240 4.8% 95.9%;
        --secondary-foreground: 240 5.9% 10%;
        --muted: 240 4.8% 95.9%;
        --muted-foreground: 240 3.8% 46.1%;
        --accent: 240 4.8% 95.9%;
        --accent-foreground: 240 5.9% 10%;
        --destructive: 0 84.2% 60.2%;
        --destructive-foreground: 0 0% 98%;
        --border: 240 5.9% 90%;
        --input: 240 5.9% 90%;
        --ring: 240 10% 3.9%;
        --chart-1: 12 76% 61%;
        --chart-2: 173 58% 39%;
        --chart-3: 197 37% 24%;
        --chart-4: 43 74% 66%;
        --chart-5: 27 87% 67%;
        --radius: 0.5rem;
        --sidebar-background: 0 0% 98%;
        --sidebar-foreground: 240 5.3% 26.1%;
        --sidebar-primary: 240 5.9% 10%;
        --sidebar-primary-foreground: 0 0% 98%;
        --sidebar-accent: 240 4.8% 95.9%;
        --sidebar-accent-foreground: 240 5.9% 10%;
        --sidebar-border: 220 13% 91%;
        --sidebar-ring: 217.2 91.2% 59.8%;
    }
    .dark {
        --background: 240 10% 3.9%;
        --foreground: 0 0% 98%;
        --card: 240 10% 3.9%;
        --card-foreground: 0 0% 98%;
        --popover: 240 10% 3.9%;
        --popover-foreground: 0 0% 98%;
        --primary: 0 0% 98%;
        --primary-foreground: 240 5.9% 10%;
        --secondary: 240 3.7% 15.9%;
        --secondary-foreground: 0 0% 98%;
        --muted: 240 3.7% 15.9%;
        --muted-foreground: 240 5% 64.9%;
        --accent: 240 3.7% 15.9%;
        --accent-foreground: 0 0% 98%;
        --destructive: 0 62.8% 30.6%;
        --destructive-foreground: 0 0% 98%;
        --border: 240 3.7% 15.9%;
        --input: 240 3.7% 15.9%;
        --ring: 240 4.9% 83.9%;
        --chart-1: 220 70% 50%;
        --chart-2: 160 60% 45%;
        --chart-3: 30 80% 55%;
        --chart-4: 280 65% 60%;
        --chart-5: 340 75% 55%;
        --sidebar-background: 240 5.9% 10%;
        --sidebar-foreground: 240 4.8% 95.9%;
        --sidebar-primary: 224.3 76.3% 48%;
        --sidebar-primary-foreground: 0 0% 100%;
        --sidebar-accent: 240 3.7% 15.9%;
        --sidebar-accent-foreground: 240 4.8% 95.9%;
        --sidebar-border: 240 3.7% 15.9%;
        --sidebar-ring: 217.2 91.2% 59.8%;
    }
}

@layer base {
    * {
        @apply border-border;
    }

    body {
        @apply bg-background text-foreground;
    }
}

.skeleton {
    * {
        pointer-events: none !important;
    }

    *[class^="text-"] {
        color: transparent;
        @apply rounded-md bg-foreground/20 select-none animate-pulse;
    }

    .skeleton-bg {
        @apply bg-foreground/10;
    }

    .skeleton-div {
        @apply bg-foreground/20 animate-pulse;
    }
}

.ProseMirror {
    outline: none;
}

.cm-editor,
.cm-gutters {
    @apply bg-background dark:bg-zinc-800 outline-none selection:bg-zinc-900 !important;
}

.ͼo.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground,
.ͼo.cm-selectionBackground,
.ͼo.cm-content::selection {
    @apply bg-zinc-200 dark:bg-zinc-900 !important;
}

.cm-activeLine,
.cm-activeLineGutter {
    @apply bg-transparent !important;
}

.cm-activeLine {
    @apply rounded-r-sm !important;
}

.cm-lineNumbers {
    @apply min-w-7;
}

.cm-foldGutter {
    @apply min-w-3;
}

.cm-lineNumbers .cm-activeLineGutter {
    @apply rounded-l-sm !important;
}

.suggestion-highlight {
    @apply bg-blue-200 hover:bg-blue-300 dark:hover:bg-blue-400/50 dark:text-blue-50 dark:bg-blue-500/40;
}

